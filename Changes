#========================================================================
#
# Changes 
#
# DESCRIPTION
#   Revision history for the Template Toolkit version 2.00, detailing
#   significant changes between versions, most recent first.  Some 
#   way down the file you'll find a section detailing major changes from 
#   version 1.* to 2.* and a list of "Gotchas!" that you might have to 
#   look out for when upgrading between major versions.
#
# AUTHOR
#   Andy Wardley   <abw@kfs.org>
#
#------------------------------------------------------------------------
# $Id: Changes,v 2.13 2000/12/01 15:29:34 abw Exp $
#========================================================================

#------------------------------------------------------------------------
# Version 2.00  1st December 2000
#------------------------------------------------------------------------

* Added the repeat(n), search(pattern) and replace(search, replace)
  virtual methods for scalars, and fixed a warning in the split()
  method raised when an attempt was made to split an undefined value.

* Changed the THROW directive to accept multiple parameters which 
  become named items of the 'error.info' item, thanks to a suggestion
  from Piers Cawley.  Positional arguments can be addressed as 
  [% error.info.n %] or as a list as [% error.info.args %].  Named 
  parameters can be accessed as [% error.info.name %].
  e.g. 
    [% TRY %]
    [% THROW foo 'one' 2 three=3.14 %],
    [% CATCH %]
       [% error.type %]        # foo
       [% error.info.0 %]      # one
       [% error.info.1 %]      # 2
       [% error.info.three %]  # 3.14
    [% END %]

* Moved the definition of Template::TieString from Template::Directive
  into Template::Config (for now) to ensure that its definition is 
  visible even if the Template::Parser, and through it, the
  Template::Directive module, haven't been loaded.  This fixes the 
  bug causing the error "Can't locate object method "TIEHANDLE" 
  via package Template::String..." raised when using EVAL_PERL with 
  compiled templates only.  In this case, the parser wasn't getting
  loaded (because it had no templates to parse, them all being pre-
  compiled) and the Template::TieString defintion wasn't visible to 
  the EVAL_PERL blocks that require it.  Added a test to t/compile3.t.
  Thanks to Igor Vylusko for reporting the problem.

* Changed the Template::Directive Perl generator for EVAL_PERL blocks
  to generate code to first test the EVAL_PERL option in the runtime
  context and throw a 'perl error - EVAL_PERL not set' exception if
  unset.  Thus the behaviour for EVAL_PERL when using compiled templates 
  is now: if the EVAL_PERL option isn't set in the _compiling_ context, 
  then Perl code will be generated which *always* throws an exception
  'perl error - EVAL_PERL not set'.  If EVAL_PERL is set, then it will
  generate code which tests the EVAL_PERL option in the _running_ 
  context (which may not be the same context that compiled it), and 
  throws the same error is the option is not set.  Note that [% RAWPERL %]
  blocks are added verbatim to the generated code if the EVAL_PERL
  option is set in the compiling context and no runtime check for 
  EVAL_PERL is made.  Similarly, [% PERL %] blocks could contain a
  Perl BEGIN block, e.g. "BEGIN { # subterfuge code here }" which 
  will always get executed at runtime, regardless of any runtime 
  EVAL_PERL option.  Thanks to Randal Schwartz for raising this issue.

* Fixed an obscure bug in WRAPPER which was causing some variables to 
  have apparently strange values when within the block content.  This
  was due to the content being formed into a closure which was called
  from within the WRAPPER template, possibly after some variable values
  had been changed.  e.g.
    [% title = "foo" %]
    [% WRAPPER outer title="bar" %]
       The title is [% title %]
    [% END %]
  Here, the 'outer' template should be called with a 'title' value of 
  'bar' but with 'content' set to 'The title is foo'.  Previously, 
  the content would have been processed from within the 'outer' template,
  resulting in a 'content' value of 'The title is bar'.  The behaviour is
  now correct.

* Filter failures are now raised as 'filter' exception types, instead
  of 'undef'.

* Applied a patch from Simon Matthews to fix some minor bugs in the 
  DBI plugin:

  - Added _connect method to Plugin::DBI for backwards compatability with 
    code from version 1 of Template that subclassed the plugin

  - Changed the new mothod on the DBI plugin so that it checks to see if 
    it is being called by a subclassed object.  

  - Fixed the return value in the DBI plugin when connect is called more 
    than once in the lifetime of the plugin

* Removed a dubious looking chomp() from Template::Plugins which may
  have caused abject stringification of any error object throw by a 
  failed plugin constructor.  Thanks to Piers Cawley for finding the 
  devious culprit.

* Changed ttree to not offer to create a ~/.ttreerc file if it doesn't
  exist when the user has specified a '-f file' on the command line.
  Thanks to Michael Stevens for raising the issue.

* Added the match($result, $expect) subroutine to Template::Test.

* Modified the final test of wrap.t to strip any trailing whitespace from
  the output due to a problem with Text::Wrap under 5.005_02.  Thanks to
  Rob Stone for reporting the problem.

* Added documentation for DEBUG options and stderr filter.  Thanks to
  Piers Cawley for spotting the omission.


#------------------------------------------------------------------------
# Version 2.00-rc2  14th November 2000
#------------------------------------------------------------------------

* Added the 'prev' and 'next' methods to Template::Iterator and 
  Template::Plugin::DBI::Iterator to return the previous and next 
  items from the data set.

* Added the 'sort' and 'nsort' virtual methods for hash arrays, 
  thanks to a patch provided by Leon Brocard.

* Various fixes to DBI plugin, configuration and test:- modified
  Makefile.PL to prompt for DBI DSN specific to user's DBD; changed
  DBI plugin to accept DBI attributes (e.g. ChopBlanks) as named
  parameters to connect method; fixed t/dbi.t to not munge 'user'
  variable in final test; added 'ChopBlanks' attributes to satisfy
  tests under certain DBD's (e.g.  Pg).  Thanks to Jonas Liljegren and
  Chris Nandor for their efforts in finding, testing and fixing the
  problems.

* Modified the XML::DOM plugin to work with XML::DOM version 1.27
  which now uses blessed array references instead of hashes as the 
  underlying data types.  Changed Makefile.PL and t/dom.t to require
  version 1.27 or later.

* Changed the Template::Iterator module to *NOT* automatically expand
  the contents of blessed ARRAY objects to construct the iteration data
  set.  The previous behaviour caused problems with modules such as 
  XML::DOM where a single object passed to the iterator constructor
  would be expanded into a list of the member data, rather than being
  treated as a single item list containing that one object.  A blessed
  ARRAY reference can now provide the as_list() method which the
  iterator constructor will call to return list data.

* Fixed a bug in Template::Provider to ensure that template metadata 
  (e.g. name, modtime, etc.) is written to compiled template files.
  Thanks to Steven Hetland for reporting the problem.

* Changed the Template::Directive::template() generator method to 
  raise an error if a context reference isn't passed to a template 
  subroutine as the first argument.

* Fixed t/autoformat.t to use locale dependant numerical formatting.
  Note that versions of Perl prior to 5.6.0 still have problems and 
  will cause t/autoform.t tests 23 and 25 to fail under locales that 
  use a decimal separator other than '.'.  The Makefile.PL will issue
  a warning in such cases.  Thanks to Jonas Liljegren for reporting 
  the problem.

* Applied a patch from Leon Brocard which corrects the behaviour of 
  the URL plugin to join parameters with '&amp;' instead of '&'.

* Fixed a bug in the AUTOLOAD method of the Template::Plugin base 
  class which caused warnings about not finding _DELEGATE pseudo-hash
  method under Perl 5.6.0.

* Various minor documentation fixes, thanks to Henrik Edlund and Leon
  Brocard.


#------------------------------------------------------------------------
# Version 2.00-rc1  1st November 2000
#------------------------------------------------------------------------

* Added the push(), pop(), unshift() and shift() virtual list methods
  and fixed the parser to allow empty lists to be created (also fixed
  the parser to prevent warnings being raised by empty hashes).
  Updated test scripts and documentation to include examples.  Thanks
  to Stas Beckman for raising the issue.

* Incorporated the DBI plugin module, written by Simon Matthews.  This 
  features a major reorganisation of the code, fixes a few bugs, removes
  some lava flow, and has improved documentation and test script.

* Updated the Makefile.PL to prompt for DBI test parameters, check for
  external modules (and in particular, versions which may cause problems)
  and various other niceties.  Also updated the README and TODO files.

* Rewrote the XML::DOM plugin, fixing the memory leakage problems and 
  adding the toTemplate() method and friends, as provided by Simon 
  Matthews.  Note that it's quite easy to send Perl into a deep
  recursive loop via the childrenToTemplate() and allChildrenToTemplate()
  methods due to a misfeature added by abw.  This will be fixed in a 
  future release and may result in behavioural changes to the
  *children* methods,  so don't rely on them too heavily for now.

* Incorporated the Dumper plugin from Simon Matthews which interfaces to
  the Data::Dumper module.

* Fixed a bug in the Datafile plugin which was causing the last data field 
  to be ignored.  Credit due (yet again!) to Simon Matthews for finding 
  the missing chomp().

* Fixed a bug in Template::Directive which was generating a 'Useless use 
  of scalar ref constructor in void context...' for empty BLOCK 
  definitions.

* Added the Wrap and Autoformat plugins which interface to Text::Wrap
  and Text::Autoformat respectively.  Thanks to Robert McArthur for the 
  original Autoformat plugin code.

* Added the XML::XPath plugin, test script and documentation.

* Fixed a bug in the Template::Service module which was using any 
  non-word characters to delimit lists of PRE/POST_PROCESS files.
  A value such as 'config, header.html' would be interpreted as 
  [ 'config', 'header', 'html' ].  It now uses the DELIMITER value
  which is ':' by default, e.g. PRE_PROCESS => 'config:header.html'
  is interpreted as [ 'config', 'header.html' ].

* Fixed a bug in the parser grammar which was failing to correctly 
  identify compound variables that contained two or more consecutive
  numbers.  For example, the variable [% pi.3.14 %] was being interpreted 
  as 'pi' . '3.14', instead of 'pi' . '3' . '14'.

* Further modified parser to accept single quoted BLOCK names that would
  otherwise choke on 'illegal' characters.  e.g. [% BLOCK 'foo bar' %]

* Changed the Template::Context::template() method to always throw an
  exception when a template can't be found instead of simply setting
  an internal error string.  Modified other Template::Context and
  Template::Service methods to expect this behaviour and act
  accordingly.  The visible impact of this is that the Template
  error() method will now always return an exception object.
  Previously there were certain cases where a plain error string would
  have been returned.

* Change the ROOT_OPS, SCALAR_OPS, HASH_OPS and LIST_OPS virtual
  method tables in Template::Stash to incorporate any existing defined
  values.  Previously, you had to 'use Template::Stash' before
  defining any new virtual methods to prevent them being overwritten
  when Template::Stash was subsequently loaded.  Thanks to Chris
  Nandor for identifying the problem and suggesting a fix.

* Changed BREAK directive to LAST to keep it in line with Perl (don't
  know why I originally chose 'BREAK' - must have had my C head on at
  the time).  BREAK is still supported as an alias for LAST.

* Renamed the Template::Iterator number() method to count(), although
  number() is still supported for backwards compatability.  The DBI 
  plugin used count() instead of number() (an oversight, I think) but I 
  decided that count() was the better name (shorter and more obvious).
  Also changed internal Template::Iterator counter variables to UPPER
  CASE to allow AUTOLOAD to be more easily reused by derived iterators
  such as the one for the DBI plugin.

* The Template::Plugin module is now derived from Template::Base.  The
  only significant ramification of this is that plugins should now
  call the error() method on failure in preference to fail().  The
  fail() method is still supported and delegates on to error(), but it
  raises a deprecation warning.

* Fixed a bug in the Table plugin which caused an "undefined variable..."
  warning to be emitted when an empty list was provided.

* Renamed 'evalperl' filter to 'perl', something that previously
  couldn't be done (before ANYCASE) due to 'perl' clashing with 'PERL'
  reserved word.  'evalperl' is still provided for backwards
  compatability.  Also added 'evaltt' as an alias for the 'eval'
  filter and 'file' as an alias for 'redirect' (which I claimed to 
  have done back in beta 3 but obviously hadn't). 

* Fixed a bug in the perl/evalperl filter which was causing a stash
  reference to be bound in a closure that could later become
  invalidated.  This could lead to variables not getting/setting their
  correct values in subsequent calls to the same filter.

* Documented the problem identified by Chris Winters where an IF 
  used as a side-effect to an implied SET directive doesn't behave as
  expected.  A directive of the form  [% foo = 'bar' IF condition %]
  should be written explicitly as [% SET foo = 'bar' IF condition %]

* Documented the 32k size limit (or typically less) for templates when 
  the INTERPOLATE option is set.

#------------------------------------------------------------------------
# Version 2.00 beta 5  14th September 2000
#------------------------------------------------------------------------

* Added define_filter($name, \&filter, $is_dynamic) method to
  Template::Context to allow additional filters to be defined at any
  time.  Arguments are as per the FILTERS configuration option.
  These filters persist for the lifetime of the processor.

* Changed the Template::Context filter() method to accept a code 
  reference as the filter name and use it as the filter sub.  This 
  allows filters to be bound to template variables which are then 
  used as:

    [% FILTER $myfilter %]

  There is one catch, however.  TT will automatically call a subroutine
  bound to a variable when evaluated.  Thus you must wrap your filter
  sub in another sub: $stash->set('foo', sub { \&myfilter }); or bless
  it into some class (any class) to fool TT into thinking it's not a 
  subroutine ref: $stash->set('bar', bless \&myfilter, 'any_old_name');

* Updated documentation for FILTER directive and FILTERS option to 
  reflect the above changes.

* Fixed Template::Document to run cleanly with taint checking enabled.
  Unfortunately, this has been achieved by blindly untainting the
  generated template Perl code before calling eval().  Given that
  we're reading template source from external files, I don't think
  there's any way to do reliable taint check anyway.  But thankfully
  we can trust the parser to generate "safe" code unless EVAL_PERL is
  enabled in which case all bets are off anyway.

* Updated XML::DOM plugin to include changes made by Thierry-Michel 
  Barral to accept configuration options for XML::Parser.

* Fixed a bug in the Table plugin which caused the first item to be
  repeated n times when n items was less than a specified number of
  columns.  Thanks to Andrew Williams for finding and fixing this
  bug.

* The Template::Tutorial document really is included in the
  distribution this time.  Honest.


#------------------------------------------------------------------------
# Version 2.00 beta 4  12th September 2000
#------------------------------------------------------------------------

* Added the PROCESS config option which allows a template or templates
  to be specified which is/are processed instead of the template
  passed as an argument to the Template process() method.  The
  original template is available as the 'template' variable and can be
  processed by calling INCLUDE or PROCESS as [% INCLUDE $template %].

* Changed what was the CASE option to now be enabled by default, and
  then changed the name of the option to ANYCASE to make it more
  obvious as to what it did.  You must now specify directive keywords
  (INCLUDE, FOREACH, IF, etc) in UPPER CASE only, or enable the
  ANYCASE option to revert to the previous behaviour of recognising
  keywords in any case.  With the increase in reserved words in
  version 2, there is more chance of collision with variable names.
  It's a real pain not being able to have a variable called 'next', an
  exception called 'perl', etc., because there's a reserved word of
  the same name.  Thus, keywords are now UPPER CASE only by default,
  neatly side-stepping the problem.

* Changed the PERL directive so that output is generated by calling
  print() instead of using the final value in the block.  Implemented
  by tying STDOUT to an output buffer based on a patch sent in by
  Chuck Adams.

    new:                      old:
      [% PERL %]                [% PERL %]
         print "foo\n";            my $output = "foo\n";
         ...                       ...
         print "bar\n";            $output .= "bar\n";
      [% END %]			   $output;
                                [% END %]

* The IMPORT directive and magical IMPORT variable have been replaced 
  with a general purpose virtual hash method, import().

    [% hash1.import(hash2) %]   # was "hash1.IMPORT = hash2"
    [% import(hash1) %]	        # was "IMPORT hash1" or "IMPORT = hash1"

* Modified the Template::Filters provider to examine the FILTERS
  package hash reference (changed name from STD_FILTERS) each time a
  filter is requested rather than copying them at construction time.
  This allows new filters to be added on-the-fly.  See t/filter.t for
  examples and Template::Filters for more info.
  
* Added the 'nsort' list method which sorts items using a numerical 
  value sort rather than an alpha sort. 

    [% data = [ 1, 5, 10, 11 ] %]
    [% data.sort.join(', ')  %]     # 1, 10, 11, 5
    [% data.nsort.join(', ') %]     # 1, 5, 10, 11  

* Added 'div' operator to provider integer division (e.g. 'a div b' =>
  'int(a / b)' and 'mod' which is identical to '%' but added for backwards
  compatibility with V1.

* Changed the (undocumented) FORNEXT directive to NEXT and documented it.

* Fixed a bug in the persistant caching mechanism in Template::Provider
  which was failing to write compiled template files for source templates
  specifed in the form [% INCLUDE foo/bar %].  Intermediate directories 
  (like 'foo' in this example) weren't being created and the disk write 
  was failing.  Thanks to Simon Matthews for identifying this problem.

* Fixed an obscure bug in the Template::Stash which was ignoring the
  last element in a compound variable when followed by an empty 
  argument list.  e.g. [% cgi.param() %] would be treated as [% cgi %].
  Also fixed the DEBUG option so that undefined variables cause 'undef'
  exceptions to be raised.  Thanks to Jonas Liljegren for reporting the 
  problems.

* Added the reference operator, '\' which allows a "reference" to 
  another variable to be taken.  The implementation creates a closure
  around the referenced variable which, when called, will return the 
  actual variable value.  It is really a form of lazy evaluation, rather
  than genuine reference taking, but it looks and smells almost the same.
  Primarily, it is useful for allowing sub-routine references to be 
  passed to another sub-routine.  This is currently undocumented 
  because I'm not sure about the validity of adding it, but see t/refs.t 
  for examples for now.

* Changed parser to automatically unescape any escaped characters in 
  double quoted strings except for \n and \$.  This permits strings to
  be constructed that include tag characters.  e.g.

    [% directive = "[\% INSERT thing %\]" %]

* Fixed a bug in the use of the 'component' variable when the current
  component is a sub-routine rather than a Template::Document.

* Added the '--define var=val' option to tpage to allow template 
  variables to be defined from the command line.  Added support to
  ttree for various new Template configuration options.

* Added $Template::Test::PRESERVE package variable which can be set to 
  prevent newlines in test output from being automatically mangled to
  literal '\n'.

* Completed and corrected all knows bugs in the documentation which
  now weighs in at around 100 pages for the Template.pm module alone.
  The POD documentation should now be installed by default.  The
  Template::Tutorial document is once again included in the
  distribution.


#------------------------------------------------------------------------
# Version 2.00 beta 3  10th August 2000
#------------------------------------------------------------------------

* Added the WRAPPER directive to include another template, passing the 
  enclosing block as the 'content' variable.  e.g.

  somefile:                    mytable:
    [% WRAPPER mytable %]        <table>
       blah blah blah            [% content %]
    [% END %]                    </table>

  This is equivalent to:

    [% content = BLOCK %]
       blah blah blah
    [% END %]
    [% INCLUDE mytable %]

* Added the [% INSERT file %] directive to insert the contents of a disk
  file without processing any of the content.  Looks for the file in the
  INCLUDE_PATH and honours the ABSOLUTE and RELATIVE flags.  Added the
  insert($file) method to Template::Context which calls the new 
  load($file) method in Template::Provider which loads the file text
  without compiling it.

* Added the DEFAULT configuration option which allows you to specify a 
  default template which should be used whenever a named template 
  cannot be found.  This is ignored for templates specified with absolute
  or relative filenames, or as references to an input filehandle or text.

* Added a FORNEXT directive to step on to the next iteration of a
  FOREACH loop, as suggested/requested by Jo Ellen Wisnosky.  I chose
  FORNEXT rather than simply NEXT because 'next' is a very common
  variable name but I'm open to better suggestions.  Perhaps CASE
  should be set by default to prevent variable conflict?  This might
  change.

* Reorganised the Template::Filters modules and changed the calling 
  convention for requesting filters via the fetch() method.  This now
  expects a reference to the calling Template::Context object as the
  third parameter (after filter name and reference to a list of arguments).
  Static filter sub-routines are returned as before and the context has
  no effect.  Dynamic filter factories (denoted by a $is_dynamic flag
  in the FILTER_FACTORY table) are called to create a filter sub-routine
  (closure) for each request.  The context is now passed as the first
  parameter, followed by the expansion of any arguments.  Filter 
  factories should return a sub-routine or (undef, $error) on error.

* Added several new filters:
  - 'stderr' prints the output to STDERR (i.e. for generating output 
    in the Apache logfile, for example).  e.g. [% message | stderr %]

  - 'file' is the equivalent of the version 1 redirect() filter which 
    writes the output to a new file, relative to OUTPUT_PATH.  Throws
    a 'file' exception if OUTPUT_PATH is not set.  There should perhaps 
    be some other way to disable this without relying on OUTPUT_PATH.

  - 'eval' evaluates the input as a template and processes it.  Proposed
    by Simon Matthews for times when you might be returning templates 
    fragments from a database, for example.  e.g. [% dirtext | eval %]

  - 'evalperl' evaluate the input as Perl code, as suggested by Jonas
    Liligren. Requires the EVAL_PERL option to be set and will throw a 
    'perl' error if not (see later item).  e.g. [% perlcode | evalperl %]

* Fixed a bug in Template::Provider which was mangling the metadata items
  for the template name and modification time.  The [% template.name %] 
  and [% template.modtime %] variables now work as expected.

* Added 'component' variable, similar to 'template', but which references 
  the current template component file or block, rather than the top-level 
  template.  Of course, these may be one and the same if you're not nesting
  any templates.

* Template::Provider now reports errors raised when re-compiling 
  modified templates rather than ignoring them, thanks to a patch from
  Perrin Harkins.

* Fixed Template::Context to recognise the RECURSION option once more,
  thanks to a patch from Rafael Kitover.

* Overloaded "" stringification of Template::Exception to call as_string(),
  again thanks to Rafael.  In a catch block you can now simply say 
  [% error %] as well as the more explicit  [% error.type %] and/or 
  [% error.info %].

* Changed Template module (via Template::Service) to return the
  exception raised rather than a pre-stringified form.  This allows
  you to test the type() and/or info() if you want, or just print it
  and rely on the automatic stringification mentioned above to format
  it as expected.  Note that the top-level process($file) method
  returns a string rather than an exception if $file can't be found.
  This is a bug, or a possible "gotcha" at the very least, and should
  get fixed some time soon.  For now, test that the error is a
  reference before attempting to call info() or type().

* Fixed a bug preventing literal newlines from being used in strings.
  Thanks to Simon Matthews for bringing it to my attention by calling 
  my hotel room at the Perl Conference and saying "Hello?  Is that the 
  Template Toolkit Helpdesk?  I have a bug to report..."  :-) 
  (I fixed it on his laptop a few minutes later - good service, eh?)

* Changed Template::Parser to not compile PERL or RAWPERL blocks if
  EVAL_PERL is not set.  Previously they were compiled but switched out
  at runtime.  This was erroneous as rogue BEGIN { } blocks could still
  be executed, as noted by Randal Schwartz.  Any PERL or RAWPERL blocks
  encountered when EVAL_PERL is disabled will now cause a 'perl' exception
  to be thrown. 

* Added a define_block($name, $block) option to Template::Context to 
  add a definition to the local BLOCKS cache.  $block can be a reference
  to a template sub-routine or Template::Document object or template 
  text which is first compiled.

* Any other errors thrown in a PERL blocks (assuming EVAL_PERL set)
  are now left unchanged.  Previously, these were converted to 'perl'
  exceptions which prevented exceptions of other kinds being throw
  from within Perl code.

* Applied a patch from Chris Dean to fix a bug in the list 'sort' 
  method which was converting a single element list into a hash.  The
  sort now does nothing unless there's > 1 elements in the list.

* Changed Template::Stash set() method to append the assigned value to
  the end of any arguments specified, rather than prepending it to the 
  front.  e.g. The foo() method called by [% myobj.foo(x, y) = z %] now
  receives arguments as foo(x, y, z) instead of foo(z, x, y).

* Changed Template::Base::error() to accept a reference (e.g. exception)
  as the first parameter.  In this case, no attempt is made to 
  concatenate (and thereby stringify) the arguments.

* Added a direct stash() accessor method to Template::Context rather 
  than relying on the slower AUTOLOAD method.

* Added an iterator() method to Template::Config to require
  Template::Iterator and instantiate an iterator, and changed
  generated code for FOREACH to call this factory method.  This fixes
  a bug with pre-compiled (i.e persistant) templates which were
  failing if Template::Iterator wasn't already loaded.  Thanks to Doug
  Steinwand, Rafael Kitover and Jonas Lilegren who all identified the
  problem and hounded me until I fixed it.  :-)
 
* Fixed a problem with persistant templates not being reloaded due to 
  the %INC hash.  This caused 1 to be returned from require() instead 
  of the compiled template.

* Added ABSOLUTE and RELATIVE options to tpage by default.

* Applied various documentation and test patches from Leon Brocard.
  Fixed docs to quote dotted exception types to prevent string
  concatenation, as noted by Randal Schwartz.  Generally added a 
  whole lot more documentation.

#------------------------------------------------------------------------
# Version 2.00 beta 2   14th July 2000
#------------------------------------------------------------------------

* Added COMPILE_DIR option.  This allows you to specify a separate 
  directory in which compiled templates should be written.  The COMPILE_DIR
  is used as a root directory and each of the INCLUDE_PATH elements is 
  created below that point.  e.g. the following options

    COMPILE_DIR  => '/tmp/ttcache', 
    INCLUDE_PATH => '/user/foo/bar:/usr/share/templates',

  would create the following cache directories:

    /tmp/ttcache/user/foo/bar
    /tmp/ttcache/usr/share/templates

  Templates originating from source files in the INCLUDE_PATH are thus 
  written in their compiled form (i.e. Perl) to the relevant COMPILE_DIR
  directory.  The COMPILE_EXT option may also be used in conjunction with
  COMPILE_DIR to append a filename extension to all compiled files.
  
* Fixed memory leaks caused by the huge circular reference that is the 
  Template::Provider's linked list of cache slots.  Added a DESTROY method 
  which walks the list and explicitly breaks the chains (i.e. the NEXT/PREV
  links), thus allowing the compiled Template::Document objects to be 
  correctly destroyed and their memory repooled.  Thanks to Perrin Harkins
  for spotting the problem.

* Added a work-around in Template::Stash _dotop() to the problem of the 
  CGI module denying membership of the UNIVERSAL class on subsequent calls
  to UNIVERSAL::isa($cgi, 'UNIVERSAL').  It works correctly the first time,
  but returns false for all subsequent calls.  Changed this generic
  "is-an-object" test to UNIVERSAL::can($cgi, 'can') on the suggestion
  of Drew Taylor who identified the problem.

* Added t/macro.t to test MACRO directive, t/compile4.t and t/compile5.t
  to test the COMPILE_DIR option.

* More complete documentation, but not yet fully complete.


#------------------------------------------------------------------------
# Version 2.00 beta 1   10th July 2000
#------------------------------------------------------------------------

* Template::Context include()/process() now works with raw CODE refs.

* Template.pm now prefixes OUTPUT with the OUTPUT_PATH when OUTPUT
  is a file name.

* Cleaned up Template::Iterator.  Now derived from Template::Base.
  Removed ACTION and ORDER now that they are supported as list pseudo
  methods in the Stash LIST_OPS.

* Fixed bug in Provider preventing updated files from being automatically
  reloaded.  Thanks to Perrin Harkins who provided the patch.

* Fixed bug in Template::Plugin::Datafile which was preventing a comment
  from being placed on the first line of the file.

* Fixed bug in parse grammer preventing commas in a META list

* Added cache persistance by writing real Perl to file (rather than
  the previous Data::Dumper dump of the opcode tree).  Had to
  re-organise a bunch of code around the parser/provider/document.  
  Activated by COMPILE_EXT configuration item.

* Added a work-around in Template::Stash to the problem of CGI disclaiming
  membership of the UNIVERSAL class after the first method call.

* Added AUTO_RESET option which is enabled by default.  Disable this 
  (AUTO_RESET => 0) for block persistance across service invocations.

* Fixed \@ quoting (and others) in Directive thanks to Perrin Harkins 
  who reported the bug and Chuck Adams who provided a patch.

* Added Date plugin and test, as provided by Thierry-Michel Barral.

* Integrated changes to Template::Test from version 1.07 and beyond.  Now 
  supports -- process -- option in expect, mainly for use of t/date.t et al.

* Integrated new upper and lower filters from 1.08, and '|' alias for FILTER
  from 1.07.

* Added new directive.t test to test chomping and comments.

* BLOCKS can now be defined as template text which gets automatically 
  compiled into a Template::Document object.

* Integrated XML plugins and tests from version 1.07

* Fixed TRIM option to work with all BLOCKs and templates.  Moved TRIMing
  operation into context process() and include() methods.  Also changed
  service to call $context->process($template) rather than call the sub/
  doc itself, thus ensuring that the output can get TRIMmed.

* Updated Template::Plugin.pm

* Added '--define' option to ttree.

* Integrated various plugins and filters from v1.07

* Moved Template::Utils::output into Template.pm?) and got rid of
  Template::Utils altogether.

* Fixed bug in Context filter() provider method which wasn't caching 
  filters with args.

* [% CASE DEFAULT %] is now an alias for [% CASE %] (the default case),
  in consistency with [% CATCH DEFAULT %] / [% CATCH %]


#------------------------------------------------------------------------
# Version 2.00 alpha 1
#------------------------------------------------------------------------

* first public alpha release of Version 2.00
 


#========================================================================
#                           VERSION 2.00
#------------------------------------------------------------------------
# The following list outlines the major differences between version 1.*
# and version 2.00 of the Template Toolkit. 
#========================================================================

New Language Features
---------------------

* New SWITCH / CASE statement.  SWITCH takes an expression, CASE takes
  a value or list of values to match.  CASE may also be left blank or
  written as [% CASE default %] to specify a default match.  Only one
  CASE matches, there is no drop-through between CASE statements.
  
    [% SWITCH myvar %]
    [% CASE value1 %]
       ...
    [% CASE [ value2 value3 ] %]   # multiple values to match
       ...
    [% CASE myhash.keys %]         # ditto
       ...
    [% CASE %]                     # default, or [% CASE default %]
       ...
    [% END %]
  
* New TRY / CATCH / FINAL construct for fully functional, nested
  exception handling.  The block following the TRY is executed and
  output if no exceptions are throw.  Otherwise, the relevant CATCH
  block is executed.  CATCH types are hierarchical (e.g 'foo' catches
  'foo.bar') or the CATCH type may be left blank or specified as [%
  CATCH default %] to provide a default handler.  The contents of a
  FINAL block, if specified, will be processed last of all, regardless
  of the result (except an uncaught exception which is throw upwards
  to any enclosing TRY block).
  
    [% TRY %]
       ...blah...blah...
       [% CALL somecode %]	  # may throw an exception
       ...etc...
       [% INCLUDE someblock %]    # may have a [% THROW ... %] directive
       ...and so on...
    [% CATCH file %]		  # catch system-generated 'file' exception 
       ...
    [% CATCH DBI %]		  # catch 'DBI' or 'DBI.*'
       ...
    [% CATCH %]	                  # catch anything else
       ...
    [% FINAL %]		          # optional
       All done!
    [% END %]

* New CLEAR directive to clear the current output buffer.  This is typically 
  used in a CATCH block to clear the output of a failed TRY block.  Any output
  generated in a TRY block up to the point that an exception was thrown will
  be output by default.  The [% CLEAR %] directive in a catch block clears
  this output from the TRY block.

    [% TRY %]
       blah blah blah, this is the current output block
       [% THROW some.error 'Danger Will Robinson!' %]
       not reached...
    [% CATCH %]
       [% # at this point, the output block contains the 'blah blah...' line
          # up to the point where the THROW occured, but we don't want it
          CLEAR
       %]
       Here we can add some more text if we want...
    [% END %]

  In general, the CLEAR directive clears the current output from the
  template or enclosing block.

* New META directive allowing you to define metadata items for your
  templates.  These are attached to the compiled template and wrapped
  up as a Template::Document object.  The 'template' variable is a
  reference to the current parent document and metadata items may be
  accessed directly.  Of particular note is the fact that the
  'template' variable is correctly defined for all PRE_PROCESS and
  POST_PROCESS headers.  Thus, your headers and footers can access
  items from the main template (e.g. title, author, section, keywords,
  flags, etc) and display them or act accordingly.
  
  mytemplate:
    [% META 
       title     = 'This is a Test'
       author    = 'Andy Wardley'
       copyright = "2000, Andy Wardley" 
    %]
  
    <h1>[% template.title %]</h1>
    blah blah
  
  header:   (a PRE_PROCESS template)
    <html>
    <head><title>[% template.title %]</title></head>
    <body>
  
  footer:  (a POST_PROCESS template)
    <hr>
    &copy; Copyright [% template.copyright or '2000, MyCompany' %]

* New RAWPERL ... END block directive allows you to write raw Perl
  code which is integrated intact and unsullied into the destination
  template sub-routine.  The existing PERL ... END directive continues
  to be supported, offering runtime evaluation of a block which may
  contain other template directives, etc, which are first evaluated
  (e.g. PERL...END processes the block and filters the output into
  Perl evaluation at runtime).

* New INSERT directive which inserts the contents of a file without 
  processing it.

* New WRAPPER directive which processes the following block into the
  'content' variable and then INCLUDEs the named file.

    [% WRAPPER table %]
       blah blah blah
    [% END %]

    [% BLOCK table %]
    <table>
    [% content %]
    </table>
    [% END %]

* Comments now only extend to the end of the current line.

    [% # this is a comment
       a = 10
       # so is this
       b = 20
    %]

  Placing the '#' character immediately inside the directive will comment
  out the entire directive

    [%# entire directive
        is ignored
    %]

* The TAGS directive can now be used to switch tag styles by name.
  Several new tag styles are defined (e.g. html, asp, php, mason).

    [% TAGS html %]
    <!-- INCLUDE header -->

* The output from any directive or block can now be captured and assigned to 
  a variable.

    [% htext = INCLUDE header %]
    [% btext = BLOCK %]
       blah blah
       [% x %] [% y %] [% z %]
    [% END %]
  
    # you can even assign the output of loops, conditions, etc.
    [% numbers = FOREACH n = [2, 3, 5, 7, 11, 13] %]
       blah blah [% n %]
    [% END %]

* The handling of complex expressions has been improved, permitting
  basic directives to contain logical shortcut operators, etc.  All 
  binary operators now have the same precedence rules as Perl.

    [% foo or bar %]             # GET foo, or bar if foo is false (0/undef)
    [% CALL func1 and func2 %]   # func2 only called if func1 returns true
    [% name = user.id or cgi.param('id') %].

* A new "x ? y : z" operation is provided as a shorthand for
  "if x then y else z"

    [% foo = bar ? baz : qux %]

* A leading '$' on a variable is now used to indicate pre-interpolation
  of that element.  This simplifies the syntax and makes it consistent
  with double-quoted string interpolation and text block interpolation
  via the INTERPOLATE flag.  If you've been relying on the version 1
  "feature" that ignores the leading '$' then you'll need to change your
  templates to remove the '$' characters (except where you really want 
  them) or set the V1DOLLAR flag to 1 to revert to the version 1 
  behaviour.  See the 'Gotchas' section below for more details.

    # version 1
    [% hash.${key} %]  [% hash.${complex.key} %]

    # version 2
    [% hash.$key %]    [% hash.${complex.key} %]

* Various new pseudo-methods have been added for inspecting and manipulating
  data.  The full list now looks something like this:

      [% var.defined %]               # variable is defined
      [% var.length %]                # length of string
      [% var.split(delim, limit) %]   # split string as Perl does

      [% hash.keys %]                 # return list of hash keys
      [% hash.values %]               # ditto hash values
      [% hash.each %]                 # ditto keys and values
      [% hash.import(hash2) %]        # merge hash2 into hash

      [% list.size %]                 # number of items in list
      [% list.max %]                  # last item number (size - 1)
      [% list.first %]                # first item    
      [% list.last %]                 # last item
      [% list.push(item) %]	      # add item to end
      [% list.pop %]		      # remove item from end
      [% list.unshift(item) %]	      # add item to front
      [% list.shift %]	              # remove item from front
      [% list.reverse %]              # return reversed order
      [% list.sort(field) %]          # return alpha sorted order
      [% list.nsort(field) %]         # return numerical sorted order
      [% list.join(joint) %]          # return items joined into single string


Configuration Options
---------------------

* Template blocks may be pre-defined using the new BLOCKS option.  These
  may be specified as template text or as references to sub-routines or
  Template::Document objects.

    my $template = Template->new({
	BLOCKS => {
	    header => '<html><head><title>[% title %]</title></head><body>',
	    footer => '</body></html>',
	    funky  => sub { blah_blah($blah); return $some_text },
	}
    });

* Automatic error handling can be provided with the ERROR option.  This
  allows you to specify a single template or hash array of templates which
  should be used in the case of an uncaught exception being raised in the
  a template.  In other words, if something in one of your templates
  throws a 'dbi' error then you can define an ERROR template to catch
  this.  The original template output is discarded and the ERROR template
  processed in its place.  PRE_PROCESS and POST_PROCESS templates (e.g.
  header and footers) are left intact.  This provides a particularly 
  useful high-level error handling abstraction where you simply create
  templates to handle particular exceptions and provide the mapping 
  through the ERROR hash.

    my $template = Template->new({
	ERROR => {
	    dbi        => 'error/database.html',   # DBI error
	    'user.pwd' => 'error/badpasswd.html',  # invalid user password
	    user       => 'user/index.html',	   # general 'user' handler
	    default    => 'error/error.html',      # default error template
	}
    });

* The INCLUDE_PATH is now fully dynamic and can be changed at any time.
  The new Template::Provider which manages the loading of template files
  will correctly adapt to chahges in the INCLUDE_PATH and act accordingly.

* The LOAD_TEMPLATES option allows you to specify a list of one or more
  Template::Provider object which will take responsibility for loading
  templates.  Each provider can have it's own INCLUDE_PATH, caching
  options (e.g CACHE_SIZE) and so on.  You can sub-class the
  Template::Provider module to allow templates to be loaded from a
  database, for example, and then define your new provider in the
  LOAD_TEMPLATES list.  The providers are queried in order as a "Chain 
  of Responsiblity".  Each may return a compiled template, raise an
  error, or decline to serve the template and pass control onto the
  next provider in line.

* The CACHE_SIZE option defines a maximum number of templates that will
  be cached by the provider.  It is undefined by default, causing all
  templates to be cached.  A value of 0 disables caching altogether while
  a positive integer defines a maximum limit.  The cache (now built into
  Template::Provider) is much smarter and will automatically reload and
  compile modified source templates.

* The Template::Provider cache can write compiled templates (e.g. Perl code)
  to disk to create a persistant cache.  The COMPILE_EXT may be used to 
  specify a filename extension (e.g. '.ttc') which is used to create
  compiled template files.  These compiled template files 
  can then be reloaded on subsequent invocations using via Perl's 
  require() (which is about as fast as it can get).  The Template::Parser 
  and Template::Grammar modules are loaded on demand, so if all templates
  have been pre-compiled then the modules don't get loaded at all.  This 
  is a big win, given that Template::Grammar is the biggy.

* The ABSOLUTE and RELATIVE options are now used to enable the loading of
  template files (via INCLUDE or PROCESS) that are specifies with absolute
  (e.g. /tmp/somefile) or relative (e.g. ../tmp/another) filenames.  Both
  are disabled by default.

* The LOAD_PLUGINS option is similar to LOAD_TEMPLATES but allows you
  to specify one or more plugin providers.  These take responsibility
  for loading and instantiating plugins.  The Template::Plugins module
  is the default provider and multiplexes requests out to other
  Template::Plugin::* plugin modules.  Loading of plugins has been
  simplified and improved in general The PLUGINS option can be used to
  map plugin names to specific modules and PLUGIN_BASE can map plugins
  into particular namespaces.  The LOAD_PERL option can be used to
  load (almost) any regular Perl module and use it as a plugin.

* The LOAD_FILTERS option is similar to LOAD_TEMPLATES and LOAD_PLUGINS, 
  allowing one or more custom providers to be specified for providing
  filters.  The Template::Filters module is the default provider here.

* The TOLERANT option can be used to tailor the behaviour of providers
  (e.g. Template::Provider, Template::Plugins, Template::Filters) when
  they encounter an error.  By default, providers are not TOLERANT (0)
  and will report all failures as errors.  When TOLERANT is set to 1,
  they will ignore errors and return STATUS_DECLINED to give the next
  provider a chance to deliver a valid resource.

* The INTERPOLATE option is now automatically disabled within PERL and 
  RAWPERL blocks to prevent Perl $variables from being interpreted as 
  template variables.

    # INTERPOLATE = 1
    This $var will get interpolated...
    [% PERL %]
       # but these won't
       my $foo = 'some value';
       my $bar = 'another value';
       # etc...
    [% END %]
    now we're interpolating variables again, like $var

* Added the TRIM option to automatically removed leading and trailing 
  whitespace from the output of templates and BLOCKs.

* The CASE option has now been obsoleted and replaces by the ANYCASE 
  option.  See comments elsewhere in this document ('Gotchas' below and 
  notes for 2.00 beta 4) for further details.


Templates Compiled to Perl Code
-------------------------------

Templates are now compiled to Perl code, with credit and respect due
to Doug Steinwand for providing an implementation around which the
new parser was built.  This brings a number of important benefits:

* Speed and Memory Efficiency

  Version 1 used a list of opcodes to represent directives and
  lower-level operations.  These were evaluated by the hideously
  contrived, and darkly sinister Template::Context::_evaluate()
  method.  In version 2, all templates are parsed and rebuilt as Perl
  code.  This is then evaluated and stored as a reference to a Perl
  sub-routine which can then be executed and re-executed significantly
  faster and with far less memory overhead.

* Persistance.

  Once a template has been compiled to Perl code it can be saved to
  disk as a "compiled template" by defining the COMPILE_EXT option.
  This allows you to specify a filename extension (e.g. '.ttc') which
  is added to the template filename and used to create a new file
  containg the Perl code.  Next time you use the template, even if
  you've shut down your program/server/computer in the mean time, the
  compiled template is there in a file as Perl code and is simply
  require()d and executed.  It all happens significantly faster
  because there's no Template::Parser to run.  In fact, if all your
  templates are "compiled" on disk then the Template::Parser and
  Template::Grammar modules won't even be loaded, further reducing
  startup time and memory consumption (the grammar file, in particular
  is rather large).  The Template::Provider module handles the
  loading, caching and persistance of templates, and will examine file
  timestamps and re-compiled modified templates as required.

* Flexibility.  

  Because "compiled templates" are now nothing more than Perl
  sub-routines, you can use anyone or anything to generate them and
  run them all under the same roof.  Different parser back-ends can
  generate Perl code optimised for speed or functionality, for
  example.  Or different parsers can compile different template
  languages (PHP, ASP, Mason, roll-your-own, etc.) and run them
  alongside regular templates.  Or if you don't trust a parser, you
  can even write your own Perl code and have your templates execute as
  fast as the code you can write.


Other Enhancements and Internal Features
----------------------------------------

* Templates (i.e. sub-routines) now return their generated output,
  rather than sending it to $context->output().  This speeds things 
  up and makes the code simpler, as well as allowing greater 
  flexibility in how template sub-routines can work.

* Exceptions are now raised via Perl's die() and caught by an
  enclosing eval { } block.  Again, this simplifies the code generated
  and improves runtime efficiency.  The [% RETURN %] and [% STOP %]
  directives are now implemented as special case exceptions which are
  caught in the appropriate place and handled accordingly.

* Local named BLOCK definitions are better behaved and don't permanently
  mask any real files.  BLOCK definitions remain local to the template in 
  which they're defined, although they can be accessed from templates 
  INCLUDEd or PROCESSed from within.  The PROCESS directive will export 
  defined BLOCKs to the caller (as with variables) whereas INCLUDE will
  keep them "private".

* The Template::Stash object now encapsulates all the magical variable
  resolution code.  Both simple and compound variables can be accessed
  or updated using the get() and set() methods, with all variable binding
  magic happening automatically.

* The Template::Context object is now greatly simplified.  This acts
  as a general interface to the Template Toolkit functionality, being
  a collection of the various other modules that actually implement
  the functionality (e.g. Template::Stash, Template::Provider,
  Template::Document, Template::Plugins, etc.)

* The Template::Provider object provides a general facility for
  retrieving templates from disk (or other source), and if necessary
  compiling via a call to a Template::Parser helper object.  Multiple
  Template::Provider objects may be chained together, each with their
  own caching options, and so on.

* The Template::Parser object now compiles template text into Perl
  code and then evaluates it into a sub-routine reference using Perl's
  eval().  This is then wrapped up into a Template::Document object,
  including any metadata items and/or additional named BLOCKs defined
  in the input template.

* The Template::Document object is a thin wrapper around a compiled
  template sub-routine.  It provides a process() method for processing
  the template and a blocks() method for returning a reference to the
  hash array of any additional named BLOCKs defined in the original
  template text.  An AUTOLOAD method returns values of metadata items,
  allowing a Template::Document reference to be used as the 'template'
  variable.

* The Template::Service module provides a high-level service for
  processing templates, allowing PRE_PROCESS and POST_PROCESS templates
  to be specified along with an ERROR handling hash.

* The Template::Base module defines a common base class for many of
  the toolkit modules.  It implements shared functionality such as a
  constructor, error reporting and handling, etc.  Modules are now
  much easier to sub-class, all using separate new() and _init()
  methods.

* The Template::Config module provides methods for loading and
  instantiating different Template Toolkit modules.  Using this
  factory-based approach makes it far easier to change the default
  object class for a specific part of the toolkit.  e.g.

      use Template;
      use Template::Config;

      $Template::Config::PARSER = 'MyOrg::Template::MyParser';

      # $tt object will create and use a MyOrg::Template::MyParser 
      # object as PARSER
      my $tt = Template->new({ ... })

* The Template::Test module has been enhanced to make it easier to test
  more advanced TT features.  You can now define multiple TT processors
  and switch between them for different test with the '-- use name --'
  directive.  Also added the '-- process --' directive which can be
  added after '-- expect --' to hav the expected output processed by
  TT before comparison.

* The Template module remains, as it ever was, a simple front-end to
  the Template Toolkit.  This creates a single Template::Service to
  which it delegates control for processing templates.  Output is
  returned according to the OUTPUT options specified for the module
  and/or any output option passed explicitly to the process() method.


New Filters
-----------

* 'upper' and 'lower' filters perform case folding of text.

* 'eval' can be used to evaluate Template Toolkit directives at runtime.

* 'perl' evaluates Perl code if (and only if) the EVAL_PERL flag is set.

* 'stderr' is a simple filter to STDERR.

* 'file' is a new alias for the 'redirect' filter.  The OUTPUT_PATH option
  must be set.


New Plugins
-----------

* The DBI plugin is now distributed with the Template Toolkit.

* The Date plugin formats dates and times via the POSIX strftime() sub.

* The Iterator plugin provides access to the Template::Iterator module.

* The Dumper plugin provides an interface to the Data::Dumper module.

* The Wrap and Autoformat plugins interface to the Text::Wrap and 
  Text::Autoformat modules respectively.

* The XML::DOM and XML::XPath plugins provide interfaces to the relevant
  XML modules.


Utility Scripts
---------------

* Added the '--define var=val' option to ttree.


Gotchas
-------

Things that have changed between version 1 and 2 that might catch you 
out.  

* Bare CATCH blocks are no longer permitted and must be explicitly
  scoped with a matching TRY.  In most cases, this simply means adding
  a [% TRY %] to the start of any templates that define CATCH blocks,
  and ensuring that the CATCH blocks are moved to the end of the file
  (or relevant place).

       # version 1 - no longer supported
       blah blah blah...some error occurs

       [% CATCH some_kind_of_error %]
          handler template...
       [% END %]

       # version 2
       [% TRY %]
       blah blah blah...some error occurs...

       [% CATCH some_kind_of_error %]
          handler template...
       [% END %]

  Also be aware that this may change the expected output in case of
  errors.  By default, all output in the TRY block up to the point of
  error will be returned, with the relevant catch block, and then and
  further template output appended.  You can use [% CLEAR %] within a
  CATCH block to clear the output from the TRY block, if you prefer.
  TRY blocks can be nested indefinately.

* The ERROR directive is no longer supported.  It was very ill-defined
  anyway and serves no purpose that can't be acheived by defining
  custom filters, error handlers bound to template variables, or
  whatever.  I haven't implemented any special error or logging
  facilities, other than the general purpose exception handling, but
  welcome any thoughts on what or if anything else is needed.

* The ERROR option is also different.  It could previously be used
  to specify an error handling sub-routine, but is no longer required
  (see previous point).  The ERROR option in version 2 is used to 
  define a map of error types to template names for automatic 
  redirection for error handling.

* The current exception caught in a catch block is now aliased to the
  variable 'error' rather than 'e'.  This is much more logical, IMHO,
  and was only prevented previously by 'error' being a reserved word.
  Note that 'e' is still defined, in addition to 'error'.  This may be
  deprecated at some point in the future.

* The use of a leading '$' on variables is no longer optional, and
  should only be used to explicitly to indicate interpolatation of a
  variable name.  Most of the time you *don't* want to do this, so
  leave the '$' off.  This represent a slight shift away from the
  (optional) Perlness of the language, but I think it's a necessary
  step to improve the clarity and consistency of the language.

    As previously discussed on the mailing list, in interpolated text
  (i.e. a "double quoted" string or regular template text with
  INTERPOLATE set), both '$foo' or '${foo}' are interpolated as the
  value of the variable 'foo'.  This is good because it is a de-facto
  standard, consistent with Perl, shell, etc.  But inside a directive,
  [% $foo %] and [% ${foo} %] mean different things, the first being
  equivalent to [% foo %] or [% GET foo %] (the leading '$' is
  ignored) but the second actually fetching a variable whose name is
  stored in the variable 'foo'.  In other words, '${foo}' interpolates
  to the value of foo ('bar', say) and then this is used as the
  parameter to GET (which itself is optional).  Thus, in this case, [%
  ${foo} %] is [% GET ${foo} %] is [% GET bar %].

  This makes more sense if you look at the common example of
  accesing an entry from a hash array using the value of an variable
  as the key (e.g. $hash->{ $key }).  In version 1, the leading '$' on
  variables is ignored, meaning that the following are NOT identical.

      # version 1
      [% hash.$key   %]     # ERROR - '$' ignored => [% hash.key %]
      [% hash.${key} %]     # OK - '$key' is interpolated first

  It gets more confusing if you excercise your right to add optional
  leading '$'s in other places (which is one reason why I've always
  suggested against their use).

      # version 1 - same as above
      [% $hash.$key   %]
      [% $hash.${key} %]

  In particular, that last example should demonstrate the
  inconsistency.  Unlike interpolated text, '$...' and '${...}' are
  not treated the same and '$hash' is not interpolate while '${key}'
  is.  The only consistent solution I can see to this is to make both
  '$xxx' and '${xxx}' indicate interpolation in all cases, so that's
  what I've done.  In version 2, the syntax becomes a lot clearer and
  aligns more closely to a markup language than a programming
  language.  I think this is a Good Thing, but let me know what you
  think...

  Here's the Version 2 summary, assuming INTERPOLATE is set.

      # version 2
      my name is $name
      my name is $user.name
      my name is ${user.name}


      [% GET name %]                 [% name %]
      [% GET user.name %]            [% user.name %]
      [% GET people.fred %]          [% people.fred %]
      [% GET people.$name        %]  [% people.$name %]
      [% GET people.${user.name} %]  [% people.${user.name} %]

      [% INCLUDE header 
         title = "Home Page for $name"
      %]
      [% INCLUDE header
         title = "Home Page for $user.name"
      %]
      [% INCLUDE header
         title = "Home Page for ${user.name}"
      %]

* Changed default TAG_STYLE to only recognise [% ... %] and not the MetaText
  compatability %% ... %% style.  Set TAG_STYLE => 'template1' to accept both,
  or 'metatext' for just %% ... %%

* Changed how error/return values should be returned from user code.
  All errors should be thrown via one of the following:

    die $error_msg;
    die Template::Exception->new($type, $info);
    $context->throw($msg);
    $context->throw($type, $info);
    $context->throw($exception);

* USERDIR and USERBLOCK are not supported (they were experimental and 
  undocumented, anyway)

* $Template::Directive::While::MAXITER is now 
  $Template::Directive::WHILE_MAX and may change again.

* into() filter is now obsolete.  You can now simply assign the output of
  another directive or block to a variable.

    [% x = INCLUDE foo %]
    [% y = BLOCK %]
       blah blah blah 
    [% END %]

* The CASE option has been removed and replaced with the ANYCASE option
  which is the logical opposite.  Directive keywords should now be UPPER
  CASE by default and the ANYCASE option can be enabled to revert to 
  the previous behaviour of accept keywords in any case.

* The IMPORT directive and magical variable have been removed and 
  replaced by a general purpose virtual hash method, import().
  [% IMPORT myhash %] should now be written [% import(myhash) %]
  and [% myhash.IMPORT = another.hash %] should be written as
  [% myhash.import(another.hash) %]

